#SoloLearn Int Lesson 11 onwards
"""FUnctional programming is centered around functions, often higher-order functions
which take other functions as arguments or return them as results"""
from turtle import color


def apply_twice(func,arg): #takes another function as its argument and calls it twice inside its body
    return func(func(arg))
def add_five (x):
    return x + 5

print(apply_twice(add_five, 10))
# this is similar to f(g(x))
"""pure functions have no sde effects and return an a value that depeds only
on their arguments, like cos(x) will have a consistent result if x is cconsistent"""
def pure_function(x,y): #this is a pure function
    temp=x+2*y
    return temp/(2*x +y)

some_list=[]
def impure(arg):
    some_list.append(arg)
#this is not a pure function because it changed some_list
"""pure function can be easier to reason, test they are more efficent.
memoization means the function can store a reuslt for a particular input
they are easier to run in parallel
they may be more difficult to write in some situations"""
"""lambda syntax allows us to create "anonymous" functions on the fly
lambda keyword followed by a list of arguments, a colon and
the expression to evaluate and return"""
def my_func(f,arg):
    return f(arg)
my_func(lambda x:2*x*x,5)#here, x:2*x*x is the new function
#They are called anonymous because they don't need a name
#Another example
x = lambda a:a + 10 #Add 10 to argument "a" and return the result
print(x(5))
#lambda functions aren't as powerful as named functions but they only take
#up a single line
def polynomial(x):
    return x**2 + 5*x+4
print(polynomial(-4))

print((lambda x: x**2+5*x+4)(-4))
"""map and filter are higher order functions that operate on lists or
iterables.
Map takes a function and an iterable as arguments and returns a new iterable
with the function applied to each argument"""
def add_five(x):
    return x + 5
nums=[11,22,33,44,55]
result=list(map(add_five,nums))
print(result)
#rewritten as a lambda function
nums=[11,22,33,44,55]
result=list(map(lambda x: x+5,nums))
print(result)
#list() to convert to a list
"""Given a lst of salaries, take the bonus as input and increase all the
salaries by that amount"""
salaries=[2000,1800,3100,4400,1500]
bonus=int(input("bonus"))
salaries=list(map(lambda x:x+bonus,salaries))
print(salaries)
#adding an asterisk like print(*var) to remove the brackets
"""the filter function filers an iterable by only leavng items that
match a condition(aka predicate)"""
nums=[11,22,33,44,55]
res=list(filter(lambda x: x%2==0,nums))
print(res)
#use list() to print as a list
"""A list that represents the ages of animals. Take a nuber as input nad output
how many of the animals are older than the given number"""
ages=[3,1,9,0.4,7,12,2,1.7,5.7,42,6.7,14.5,21]
q=float(input("Age"))
dog=len(list(filter(lambda x:x>q, ages)))
print(dog)
"""generators are a type of iterable. they can be iterated through with "for" loops.
They are created using functions and the yield statement"""
def countdown():
    i=5
    while i>0:
        yield i
        i -= 1
for i in countdown():
    print(i)
   #the yield statement defines the generator
#generators dont have the memory restrictions of lists, they can be infinite
"""def infinite_sevens():
    while True:
        yield 7
for i in infinite_sevens():
    print(i)

generators declare a function that behaves like an iterator so it can be used in a for loop."""
#FInite generators can be converted into lists using the list() function
def numbers(x):
    for i in range(x):
        if i%2 ==0:
            yield i
print(list(numbers(11)))
"""Create  a generator function theat will take two numbers as arguments and output the prime numbers in the range"""
# If given number is greater than 1
num=int(input("small number "))
numtwo=int(input("larger number "))
def primeis(x):
    if x > 1:
    # Iterate from 2 to n / 2
            for i in range(2, int(x/2)+1):
  
        # If num is divisible by any number between
        # 2 and n / 2, it is not prime
                if (x % i) == 0:
                    return False
            else:
                return True
    else:
            return False


def prime_nums(x,y): #generate a list of prime number
    for i in range(x,y): #for numbers in range x to y
        if primeis(i) == True: #if the number is prime
            yield i

print(list(prime_nums(num,numtwo)))
"""Decorators are a way to modify functions using other functions. Use when functions needs
new uses but want to leave the og fucntion alone"""

def decor(func): #defined function named decor with a single parameter "func"
    def wrap(): #inside decore is nested fucntion, "wrap"
        print("======") #wrap prints a string
        func() #then calls another function 
        print("======") #then prints another string
    return wrap #the decorfunction then returns the wrap function as its results

def print_text(): 
    print("Hello World!")

decorated=decor(print_text)
decorated()

print_text=decor(print_text)
print_text() 
#this will also have the same output
"""a function can be wrapped in a decorator by using @decoratorname"""
@decor
def print_text():
    print("Hello World!") #this will have the same output as well
#a single function can have multiple decorators
"""add a decorator for an invoicing system to print the invoice in the 
required format

Input 42
output
***
INVOICE #42
***
END OF PAGE"""
def decorat(func):
    def aster(arg): #the (arg) is important here
        print("***") #wrap prints a string
        func(arg) #the (arg) is important here
        print("***") 
        print("END OF PAGE")
    return aster 
@decorat
def invoice(x): 
    print("INVOICE #"+x)

a=input("Invoice number ")
invoice(a)
"""Recursion is functions calling themelves.Used to solve problems
that can be broken into easier sub-problems of the same type
The factorial function finds the factorial of a specified number
ex 5! (5 factorial). This is recursively because 5!=5*4! and 4!=4*3!
so on and so forth. 1!= 1, this is the base case"""
def factorial(x):
    if x ==1:
        return 1
    else:
        return x * factorial(x-1)

print(factorial(5))
"""in this case the base case acts the exit condition of the recursion
The base case is the case that doesn't call the function any further
not adding the base case would result infinite function calls and crash the program
recursion is useful for creating loops when the number of loops is unknown
recursion can be used in generators by using "yield from" instead of yield"""
"""recursion can be indirect. For instance, if a function can call another, which calls the first which calls the second
so on and so forth"""
def is_even(x):
    if x==0:
        return True
    else:
        return is_odd(x-1)

def is_odd(x):
    return not is_even(x)

print(is_odd(17))
print(is_even(23))

"""fix the following code by adding a base case for recursion 
then take a number from input() to output the result"""
def convert(num):
    if num == 1:
        return 1
    else:
        return(num%2+10*convert(num//2))

print(convert(int(input("insert an integer "))))
"""Functions can have verying number of arguments. Using *args 
as a function parameter allows an arbitrry number of arguments 
to that function. The arguments can be presented as the tuple args in the 
body of the function"""

def function(named_arg, *args):
    print(named_arg)
    print(args)

function(1,2,3,4,5)
#there cannot be two *args in a function. It causes ambiguity
"""**kwargs(keyword arguments) allow you to handle named arguments that have
not been defined in advance
the keyword arguments return a dictionar in which the keys are arguent names and
the values are the argument values"""

def my_func(x,y=7, *args, **kwargs):
    print(kwargs)

my_func(2,3,4,5,6,a=7,b=8) #a and b are the arguments that we passed to the function calls
#the arguments returned by **kwargs are not included in *args
#arg returns a tuple, kwarg returns a dictionary. the exact words
#arg and kwarg do not need to be used. just use the *single asterisk or the **doubleasterisk
#args annot be defined after kwargs

"""improve  the function so it can take any number of variables"""
def my_min(x,*args):
    return min(x,*args)
print(my_min(8,13,4,42,120,7))
"""Given a string as input, use recursion to output each letter of the string 
reverse order on a new line
Input HELLO
Output
O
L
L
E
H"""
"""
def spell(y):
    a=len(y)-1
    #b=0
    #c=a-b
    if a== -1:
        print("None")
    else:
        print(y[a])
        #return spell(y.replace([a],""))
        y=y.replace([a]," ")
        print(y)
txt=str(input("txt"))
spell(txt)
"""
def reverse(text):
    n = len(text)
    if n:
        print(text[-1])
    if 1 < n:
        reverse(text[:-1])

reverse('PYTHON')
